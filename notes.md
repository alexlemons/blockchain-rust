## Notes

**https://github.com/GeekLaunch/blockchain-rust**

Blockchain two main data structures:

- The blocks in the blockchain
- The transactions within the blocks

Ancillary data:

- Wallets
- Addresses
- Balances
- Peers

Blockchain ≈ chronological, sequential list of blocks, linked-list

Our blocks will contain the following information:

- Index: the blocks location within the list of blocks
- Payload: any relevant information or events that have occurred for/in the block
- Timestamp
- Nonce: special number used for mining (POW verification)
- Previous block hash: cryptographic fingerprint of previous block
- Hash: cryptographic fingerprint of all of the above data concatenated together

Hash: unique string sequence, irreversibly generated by hash algorithm:A hash is a unique, reproducible fingerprint for some data.

- Hashing is a one way function, you cannot get the original string back from the hash
- Makes it possible to check the equality of data, without revealing data contents
- the same data will always produce the same hash
- eg.SHA-256: 256 bits (32 bytes)
- "avalanching" used, if input changes just slightly, the output changes significantly
- (Encrypting is a reversible two way function)

Integer types:

- signed integer (32-bit) encodes an integer in the range -2147483648 to 2147483647.
- unsigned integer (32-bit) encodes an integer in the range 0 to 4294967295 (positive only).

u8: 0 - 255 (2^8)
u32: 0 - 4,294,967,295 (2^32)

Bitcoin Mining: https://www.investopedia.com/tech/how-does-bitcoin-mining-work/

Nonce:

This additional arbitrary piece of data is added as a field on the block, and hashed along with the other data.

Mining difficulty is a measure of hard it is to mine a block. Used to keep the time between blocks consistent
as the network's hash power changes.

By changing the nonce we can eventually generate a hash that matches the difficulty. The blockchain miners are finding a hash that matches the difficulty. (one miner calculates correct nonce ~ 10min and receives reward for creating new block)

The most significant 16 bytes of the hash (converted to u128) must be lower than the difficulty (u128) before the block is considered valid.

An increased difficulty results in a more secure network. Difficulty is adjusted depending on the hash power / number of miners on
the network.

Mining strategy (Proof of Work):

1. Generate a nonce
2. Generate hash (computationally heavy step)
3. Check hash against difficulty
   a. invalid? go to step 1
   b. valid? go to step 4
4. Add block to chain
5. Submit to peers...etc

Block verification - we verify new blocks received from a peer. Different block properties can be verified.

Transaction verification:

- overspending (where did the coins come from)
- double spending (are the coins available)
- impersonation (who owns the coins and who is sending them)
- ...many more: https://en.bitcoin.it/wiki/Protocol_rules#.22tx.22_messages

Transactions contain two important pieces of information, inputs and outputs:

- set of inputs (which are unused outputs from previous transactions)
- set of outputs (new outputs that can be used in future transactions)

From here we can calculate:

- the value of the transaction: Σinputs
- the value of the fee: Σinputs - Σoutputs

ie:

50 -> [12][36]
fee = 2

Overspending verification: the sum of the value of the inputs must be greater than or equal to the sum of the generated outputs.

Double-Spending verification: make sure that any one output is never used as an input more than once. The can be done by maintaining a pool of unspent outputs and rejecting any transaction that tries to spend outputs that don't exist in the pool.

Impersonation verification: The can be solved by adding a cryptographic signature to the outputs to verify they're being spent by their owner.
